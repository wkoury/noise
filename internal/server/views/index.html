<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Brown Noise WASM</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }

    .container {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-bottom: 30px;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .control-group label {
      min-width: 100px;
      font-weight: bold;
    }

    .control-group input[type="range"] {
      flex: 1;
      margin: 0 10px;
    }

    .control-group span {
      min-width: 50px;
      text-align: center;
      font-family: monospace;
      background: #f0f0f0;
      padding: 5px 10px;
      border-radius: 4px;
    }

    #start {
      padding: 15px 30px;
      font-size: 18px;
      border: none;
      border-radius: 8px;
      background: #007bff;
      color: white;
      cursor: pointer;
      display: block;
      margin: 0 auto;
      transition: background-color 0.2s;
    }

    #start:hover {
      background: #0056b3;
    }

    #start:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }

    .info {
      margin-top: 30px;
      padding: 15px;
      background: #e9ecef;
      border-radius: 5px;
      font-size: 14px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéµ Brown Noise Generator</h1>

    <div class="controls">
      <div class="control-group">
        <label for="damping">Damping:</label>
        <input type="range" id="damping" min="0.1" max="1.0" step="0.01" value="0.90">
        <span id="dampingValue">0.90</span>
      </div>

      <div class="control-group">
        <label for="gain">Volume:</label>
        <input type="range" id="gain" min="0.0" max="1.0" step="0.01" value="0.50">
        <span id="gainValue">0.50</span>
      </div>

      <div class="control-group">
        <label for="stepSize">Smoothness:</label>
        <input type="range" id="stepSize" min="0.001" max="0.1" step="0.001" value="0.020">
        <span id="stepSizeValue">0.020</span>
      </div>
    </div>

    <button id="start">‚ñ∂Ô∏è Start Brown Noise</button>

    <div class="info">
      <strong>About Brown Noise:</strong> Brown noise (also called Brownian noise) is a type of audio signal that has more energy at lower frequencies.
      It's often used for relaxation, focus, and masking unwanted sounds. Adjust the controls above to customize the sound to your preference.
    </div>
  </div>

  <script src="wasm_exec.js"></script>
  <script>
    // Bootstrap Go WASM
    const go = new Go();
    let instance;
    let audioCtx;
    let node;
    let isPlaying = false;

    // Update display values for sliders
    const dampingSlider = document.getElementById("damping");
    const gainSlider = document.getElementById("gain");
    const stepSizeSlider = document.getElementById("stepSize");
    const dampingValue = document.getElementById("dampingValue");
    const gainValue = document.getElementById("gainValue");
    const stepSizeValue = document.getElementById("stepSizeValue");

    dampingSlider.oninput = () => dampingValue.textContent = parseFloat(dampingSlider.value).toFixed(2);
    gainSlider.oninput = () => gainValue.textContent = parseFloat(gainSlider.value).toFixed(2);
    stepSizeSlider.oninput = () => stepSizeValue.textContent = parseFloat(stepSizeSlider.value).toFixed(3);

    WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject)
      .then(res => {
        instance = res.instance;
        return go.run(res.instance);
      })
      .catch(err => {
        console.error("Failed to load WASM:", err);
      });

    document.getElementById("start").onclick = async () => {
      const button = document.getElementById("start");

      if (isPlaying) {
        // Stop the audio
        if (node) {
          node.disconnect();
          node = null;
        }
        if (audioCtx) {
          await audioCtx.close();
          audioCtx = null;
        }
        button.textContent = "‚ñ∂Ô∏è Start Brown Noise";
        button.style.background = "#007bff";
        isPlaying = false;
      } else {
        try {
          // Get current slider values
          const damping = parseFloat(dampingSlider.value);
          const gain = parseFloat(gainSlider.value);
          const stepSize = parseFloat(stepSizeSlider.value);

          // Initialize with current parameters
          initStreamer(damping, gain, stepSize);

          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const bufferSize = 4096;
          node = audioCtx.createScriptProcessor(bufferSize, 0, 2);

          node.onaudioprocess = e => {
            try {
              // Pull Float32Array back from WASM
              const samples = nextSamples(bufferSize);
              const left = e.outputBuffer.getChannelData(0);
              const right = e.outputBuffer.getChannelData(1);
              for (let i = 0; i < bufferSize; i++) {
                left[i] = samples[i*2];
                right[i] = samples[i*2 + 1];
              }
            } catch (error) {
              console.error("Error processing audio:", error);
            }
          };

          node.connect(audioCtx.destination);
          button.textContent = "‚èπÔ∏è Stop";
          button.style.background = "#dc3545";
          isPlaying = true;
        } catch (error) {
          console.error("Failed to start audio:", error);
          alert("Failed to start audio. Please try again.");
        }
      }
    };

    // Update parameters in real-time when sliders change
    dampingSlider.onchange = () => {
      if (isPlaying) {
        initStreamer(
          parseFloat(dampingSlider.value),
          parseFloat(gainSlider.value),
          parseFloat(stepSizeSlider.value)
        );
      }
    };

    gainSlider.onchange = () => {
      if (isPlaying) {
        initStreamer(
          parseFloat(dampingSlider.value),
          parseFloat(gainSlider.value),
          parseFloat(stepSizeSlider.value)
        );
      }
    };

    stepSizeSlider.onchange = () => {
      if (isPlaying) {
        initStreamer(
          parseFloat(dampingSlider.value),
          parseFloat(gainSlider.value),
          parseFloat(stepSizeSlider.value)
        );
      }
    };
  </script>
</body>
</html>
